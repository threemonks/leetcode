youtube seminar from wisdompeak
https://www.youtube.com/watch?v=FLbqgyJ-70I&list=PL4eek-kYmeR1H9vbuzxtf9lJb3TVW-obm&index=5

slides from this google doc:
https://docs.google.com/presentation/d/1F_Qp3kzw7jZkPpb7ll7J6-02285bCA3Z9nmU1e7a2rk/edit#slide=id.g8285dd8f3f_1_512

DP适用问题：
    能将大问题拆成几个小问题，且满足无后效性、最优子结构性质。

*** TOC ***
** DP套路(I): 第I类基本型（“时间序列”型）
    - dp[i][j]：表示第i-th轮的第j种状态 (j=1,2,...,K)
** DP套路(II): 第II类基本型（“时间序列”加强版）
    - dp[i]：表示第i-th轮的状态，一般这个状态要求和元素i直接有关。dp[i]与之前的状态dp[i’]产生关系(i=1,2,...,i-1) (比如sum, max, min)
** DP套路(III): 双序列型
    - dp[i][j]：表示针对s[1:i]和t[1:j]的子问题的求解。dp[i][j]往之前的状态去转移：dp[i-1][j], dp[i][j-1], dp[i-1][j-1]
** DP套路(IV): 第I类区间型DP
    - dp[i][k]表示针对s[1:i]分成k个区间，此时能够得到的最优解。搜寻最后一个区间的起始位置j，将dp[i][k]分割成dp[j-1][k-1]和s[j:i]两部分。
** DP套路(V): 第II类区间型DP
    - dp[i][j]：表示针对s[i:j]的子问题的求解。dp[i][j]往小区间的dp[i’][j’]转移
** DP套路(VI): 背包入门 Knapsack Problem
    - dp[i][c]：表示考虑只从前i件物品的子集里选择、代价为c的最大收益。c = 1,2,...,C。将dp[i][c]往dp[i-1][c’]转移：即考虑如何使用物品i，对代价/收益的影响
** 状态压缩 （01背包）Knapsack Problem bit masking
    - 设计“状态”代表一个01向量（不超过32位），我们可以用一个整形的bit位来表示

***********
** DP套路(I): 第I类基本型（“时间序列”型）

给出一个序列（数组/字符串），其中每一个元素可以认为“一天”，并且“今天”的状态只取决于“昨天”的状态。
House Robber
Best Time to Buy and Sell Stocks
...
套路：
定义dp[i][j]：表示第i-th轮的第j种状态 (j=1,2,...,K)
千方百计将dp[i][j]与前一轮的状态dp[i-1][j]产生关系(j=1,2,...,K)
最终的结果是dp[last][j]中的某种aggregation (sum, max, min …)

* To Do or Not To Do
很多不是那么套路的DP题，DP状态可能比较难设计。不过还是有套路可循。
某些题目给你一次“行使某种策略的权力”。联想到买卖股票系列的题，我们常会设计的两个状态就是“行使了权力”和“没有行使权力”分别对应的价值。

** DP套路(II): 第II类基本型（“时间序列”加强版）
给出一个序列（数组/字符串），其中每一个元素可以认为“一天”：但“今天”的状态 和之前的“某一天”有关，需要挑选。
套路：
定义dp[i]：表示第i-th轮的状态，一般这个状态要求和元素i直接有关。
千方百计将dp[i]与之前的状态dp[i’]产生关系(i=1,2,...,i-1) (比如sum, max, min)
dp[i]肯定不能与大于i的轮次有任何关系，否则违反了DP的无后效性。
最终的结果是dp[i]中的某一个

** DP套路(III): 双序列型
给出两个序列s和t（数组/字符串），让你对它们搞事情。
Longest Common Subsequences
Shortest Common Supersequence
Edit distances
...
套路：
定义dp[i][j]：表示针对s[1:i]和t[1:j]的子问题的求解。
千方百计将dp[i][j]往之前的状态去转移：dp[i-1][j], dp[i][j-1], dp[i-1][j-1]
最终的结果是dp[m][n]

* LCS/SCS的变种：换汤不换药
LC 583. Delete Operation for Two Strings
问：从字符串s和t中总共最少删除多少个字符能使得它们相等。
LC 712. Minimum ASCII Delete Sum for Two Strings
问：从字符串s和t中总共最少删除多少ASCII码值的字符能使得它们相等。
LC 1035. Uncrossed Lines
两个数组s和t之间相等的数字可以连线。连线不能交叉。问最多可以有几条连线。
LC 1216. Valid Palindrome III
问一个字符串s最少删除多少个字符能变成回文串。
LC 1312. Minimum Insertion Steps to Make a String Palindrome
问一个字符串s最少需要添加多少个字符能变成回文串。

T = S[:-1]
S

** DP套路(IV): 第I类区间型DP
给出一个序列，明确要求分割成K个连续区间，要你计算这些区间的某个最优性质。
套路：
状态定义：dp[i][k]表示针对s[1:i]分成k个区间，此时能够得到的最优解
搜寻最后一个区间的起始位置j，将dp[i][k]分割成dp[j-1][k-1]和s[j:i]两部分。
最终的结果是dp[N][K]

** DP套路(V): 第II类区间型DP
只给出一个序列S（数组/字符串），求一个针对这个序列的最优解。
适用条件：这个最优解对于序列的index而言，没有“无后效性”。即无法设计dp[i]使得dp[i]仅依赖于dp[j] (j<i). 但是大区间的最优解，可以依赖小区间的最优解。
套路：
定义dp[i][j]：表示针对s[i:j]的子问题的求解。
千方百计将大区间的dp[i][j]往小区间的dp[i’][j’]转移。
第一层循环是区间大小；第二层循环是起始点。
最终的结果是dp[1][N]

* 结合第I类和第II类区间型DP算法的Boss题：
LC 1000. Minimum Cost to Merge Stones
给一个数组代表N堆石头的重量。每步操作将K堆相邻的石头合并，代价是这K堆的重量和。问最少的代价将所有的石头堆合并到一起。
我们考虑将任意区间[i:j]归并到一起的最优解，取决于如何先最小代价地将[i:j]归并成K堆（即先分成K个subarray），然后再加sum[i:j]即可。于是提示我们需要结合两类区间型DP的套路：
dp[i][j][k]表示将区间[i:j]归并成k堆的最小代价。

** DP套路(VI): 背包入门
题型抽象：给出N件物品，每个物品可用可不用（或者有若干个不同的用法）。要求以某个有上限C的代价来实现最大收益。（有时候反过来，要求以某个有下限的收益来实现最小代价。）
套路：
定义dp[i][c]：表示考虑只从前i件物品的子集里选择、代价为c的最大收益。c = 1,2,...,C
千方百计将dp[i][c]往dp[i-1][c’]转移：即考虑如何使用物品i，对代价/收益的影响
第一层循环是物品编号i；
第二层循环是遍历“代价”的所有可能值。
最终的结果是 max {dp[N][c]}, for c=1,2,...,C

题型抽象：给出N件物品，每个物品可用可不用（或者有若干个不同的用法）。要求以某个有上限C的代价来实现最大收益。（有时候反过来，要求以某个有下限的收益来实现最小代价。）
背包问题的解法特点：
利用了物品次序的“无后效性”：我在前4件物品中做选择的最大收益，与第5件物品是啥没有关系。
“过去不依赖将来，将来不影响过去”
将原本题意的解空间（代表各种物品是否使用的高维向量），替换成了代价的解空间（是一个有上限C的标量）。压缩了复杂度。
[0,2,0,3,1,0,0,4]  => {10}

** 状态压缩
对于比较复杂的“状态”，DP经常会用到“状态压缩”的技巧。
比如：有些情况下如果想设计“状态”代表一个01向量（不超过32位），我们可以用一个整形的bit位来表示。
[1,0,1,1,0,0,1] => b1011001 => 89

